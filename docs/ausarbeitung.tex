\documentclass[german]{article}

\usepackage{listings}
\lstset{numbers=left, numberstyle=\tiny, numbersep=5pt}
\lstset{language=Java}
\usepackage{german}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}


\makeatletter
\makeatother

\begin{document}

\title{Teamfound}

\author{Jonas Heese, ...}

\date{März 2006}

\maketitle

\abstract{TeamFound ist eine Teamsuchmaschine und ist im Wintersemester 2005/2006 während des Projekts "Infrastrukturen zur Open Source Softwareentwicklung"
 an der Technischen Universität Berlin entstanden



\pagebreak

\tableofcontents{}

\pagebreak

\section{Einleitung}

TeamFound ist wie man bereits aus dem Namen schliessen mag eine Suchmaschine für Teams. Der Vorteil einer eigenen Suchmaschine liegt ganz einfach darin, das nicht jedes Teammitglied eine herkömmliche Suchmaschine bemühen muss um Inhalte zu finden, die ein anderes Teammitglied bereits recherchiert hat. Andererseit sist es aber nicht gesagt, das die gesuchten Informationen wirklich schon in der eigenen Teamsuchmaschine vorhanden ist, daher suchen TeamFound-Clients immer auch in einer zweiten herkömmlichen Suchmaschine.

Bisherige Technik um Suchergebnisse zu verteilen integrieren sich dagegen sehr viel schlechter in einen vorhandenen Arbeitsprozess, zum Beispiel könnten einfache Bookmarks ausgetauscht werden, diese sind aber unter Umständen nicht von allen Teammitgliedern veränderbar, die Integration in einen Webbrowser ist hier quasi nicht vorhanden. 

Eine weitere Möglichkeit bieten Kataloge\footnote{Jede größere Suchmaschine bietet eigene Kataloge. Das DMOZ-Projekt (http:/www.dmoz.org) stellt einen unabhängigen Versuch dar, das Internet zu kategorisieren} oder Verschlagwortungen wie del.icio.us \footnote{http://del.icio.us}, selbst wenn eine derartige Software in Form einer Teamsuchmaschine eingesetzt werden können, bieten sie eigentlich keine Integration in vorhandene Browser und damit würden vorhandene Arbeitsabläufe nachhaltig gestört.
\\
TeamFound will - gerade durch die Integration in bekannte Browser - diese Integration einfacher möglich machen. Das Hinzufügen neuer Seiten sowie das Suchen im eigenen Index ist durch eine einfache Toolbar oder - genau wie bei bekannten Suchmaschinen - mittels einer Webseite möglich. Dabei können Seiten nicht nur in den Index eingefügt werden sondern auch in beliebig viele Kategorien einsortiert werden, welche wiederrum einzeln oder als Baum durchsucht werden können.

\section{TeamFound}

TeamFound besteht aus mehreren Komponenten, zentraler Bestandteil ist wie bei allen anderen vorgestellten Technologien ein Server, welche Suchanfragen entgegennimmt, deren Ergebnisse übermittelt und sich außerdem um das herunterladen neuer Seiten und deren einfügen in den Index kümmert. Anders als bei anderen Technologien, ist die Client-Integration aber seit Beginn des projektes Teil der Planungen. TeamFound implementiert Clients unter anderem als Toolbar in bekannte Browser, natürlich ist es auch für ein geeignetes Webfrontend möglich TeamFound-Server zu benutzen, genauso wie auch andere Suchmaschinen meist über deren Internetseiten benutzt werden. Allerdings wurde bei der Clientkonzeption von TeamFound eher auf die Möglichkeiten von Browsererweiterungen eingegangen, als auf die Anforderungen von Webseiten.

Im Folgenden werden die einzelnen Teile von TeamFound detailliert dargestellt. Dabei handelt es sich zuerst um den TeamFound-Server und anschliessend um die Toolbars für den Firefox-Browser vom Mozilla-Projekt sowie der Integration in den Internet Explorer von Microsoft. Da diese Browser auf sehr unterschiedlicher Technik basieren werden die einzelnen Toolbars auch getrennt beschrieben.

\subsection{Funktionsumfang}

\subsubsection{Suchanfragen}

\subsubsection{Kategorien}
\label{kategorien}



\section{Teamfound-Server}


\subsection{Anforderungen}


\subsection{Plattform}

Die Entscheidung für eine Plattform wurde implizit durch die Entscheidung für eine Bibliothek zum indexieren und durchsuchen von Dokumenten getroffen. Nachdem einige Tage nach derartigen Bibliotheken Ausschau gehalten wurde, ist sehr schnell deutlich geworden, das Lucene \footnote{www.lucene.de} vom Apache-Projekt\footnote{http://www.apache.org} die am weitest entwickelte Bibliothek ist. Ein weiterer Vorteil ist die aktive Community rund um Lucene, so wurde während unserer Entwicklung noch ein Sprung von Version 1.5 auf 1.9 mitgemacht. Andere Bibliotheken, zum Beispiel in Perl oder PHP boten keine ausreichende Dokumentation oder Erweiterbarkeit.
Die ursprüngliche Lucene-Version ist in Java implementiert, ein weiteres Projekt bemüht sich um dessen Umsetzung in C und mittlerweile (Am Ende des Projekts hat Zend Technologies\footnote{http://www.zend.com} einen PHP-Wrapper\footnote{http://framework.zend.com/manual/en/zend.search.html} für Lucene veröffentlicht.

Somit war die Wahl der Plattform auf Java gefallen, eine erste mehr als Proof-of-Concept anzusehende Version von Teamfound wurde mittels zwei Perl-CGI-Scripten und einem Systemaufruf der Lucene-Bibliothek umgesetzt. Dieses Vorgehen startet bei jeder Anfrage an den Webserver eine neue Java virtuel machine, was natürlich überhaupt nicht effektiv ist. 

Daher fiel eine weitere Entscheidung, für eine Java-Servlet-Umsetzung, um die benötigte Umgebung für Anfragen an den Lucene-Index nicht für jedes Request neu zu schaffen. Somit besteht der Server aus einer 100\%igen Java-Umgebung und es entfällt damit die Notwendigkeit für aufwändige und zeit-kostende Wrapper um mehrere Programmiersprachen zu verbinden.

\subsection{Kernbibliotheken}

\subsubsection{Apache Lucene}

Lucene ist - laut eigener Aussage - der harte Teil einer Suchmaschine. Diese Bibliothek erzeugt und durchsucht einen Volltextindex, kümmert sich aber weder darum wo die Daten herkommen, wie die Ergebnisse präsentiert werden oder wie die Suchanfragen vom Benutzer an den Index kommen. Der Index ist hingegen bietet viele Möglichkeiten die eigenen Daten zu analysieren und in sogenannten Dokumenten in den Index zu speichern. Eigene $Analyzer$ sind mit wenig Aufwand umzusetzen (sofern die mitgelieferten nicht ausreichen), auch aufwändigere Parser sind möglich, wie es zB. für HTML-Seiten notwendig ist.
Darüberhinaus kann jedes Dokument im Index beliebige $Felder$ enthalten, ein Feld ist als Inhaltselement eines Dokuments zu verstehen (Überschrift, Inhalt, Beschreibung). Dabei können völlig verschiedene Arten von Dokumenten in einem Index gespeichert werden sowie Suchanfragen direkt an ein oder mehrere Felder gestellt werden. Diese starke Erweiterbarkeit ist zum Beispiel bei der Implementierung von Dokumentenkategorien in TeamFound sehr wichtig gewesen (Siehe Kapitel \ref{kategorien})

TODO: Query Syntax, beteiligte Arten von Klassen genauer ausführen (Analyzer, Document, Field, IndexReader, IndexWriter, Query, QueryParser, ....)

\subsubsection{HSQLDB}

\subsubsection{Weitere Bibliotheken}

jdom

\subsection{Architektur}

\subsubsection{Servlet}

Das Servlet ist der Einstiegspunkt für jegliche Anfragen an TeamFound. Dem Servlet kommt dabei die Rolle eines Wächters zu, welcher überprüft ob notwendige Parameter für die einzelnen Anfragen vorhanden sind. Ist eine Anfrage gültig, wird diese an den sogenannten Controller weitergereicht, welcher die eigentlichen TeamFound-Komponenten steuert. Dieser Controller gibt immer ein Response-Objekt zurück, welches vom Servlet dann zB. als XML oder HTML serialisiert und als Antwort zum Client geschickt wird.

\subsubsection{Controller}

\subsubsection{Indexer}

\subsubsection{Response}

Antworten werden in TeamFound immer als XML generiert, diese XML\-Repräsentation kann bevor sie zum Client geschickt wird, noch mittels XSLT in eine geeignete HTML\-Fassung gewandelt werden.
Eine Basisklasse Response übernimmt dabei das Handling des eigentlichen JDOM-Document-Objektes, während die eigentlichen Antwort\-Klassen, wie SearchResponse oder AddPageResponse ihre eigentlichen Inhalte an die Standardelemente einer Antwort anhängen (Siehe dazu mehr im Kapitel Protokoll TODO: LINK).

\subsection{Ablauf eines Requests}

Komplette Beschreibung, evtl. auch mit Diagramm

\section{Protokoll}

Jeweils Anfrage und Antworten

\begin{itemize}
\item Zielsetzung und Sinn des Protokolls
\item Umsetzung (Designentscheidungen, Technik,...)
\item Dokumentation (Wie siehts wirklich aus)
\end{itemize}

\section{Clients}

\subsection{Web-Client}

\subsection{Firefox-Toolbar}

\subsection{Internet Explorer-Toolbar}

Auch beim Internet Explorer stand zunächst die Frage wie dieser überhaupt zu erweitern ist. 
Google und Yahoo haben mit ihren Toolbar's vorgemacht das es geht, nur das wie war zu lösen.

Erste Anlaufstelle um der Problemlösung näher zu kommen 
war CodeProject (www.codeproject.com). 
Mit 2,8 Mio Mitgliedern ist sie die größte Community Seite für die Windows Entwicklung. 
Eine Suche nach ``IE Toolbar'' führte zu einer .NET basierten Bibliothek 
für die Entwicklung von BandObjects, also Band Objekten (http://www.codeproject.com/csharp/dotnetbandobjects.asp).
Das mitgelieferte Beispiel funktionierte auf Anhieb 
und es wurde begonnen die Extension zu implementieren.

\subsubsection{Custom Explorer Bars, Tool Bands, and Desk Bands}

Es gibt verschiedene Möglichkeiten eigene Komponenten in den Internet Explorer zu integrieren. 
Im folgenden werden einige Konzepte vorgestellt.

\paragraph{Explorer Bars}

Ein zentrales Konzept zur Erweiterung des Internet Explorers, sind Explorer Bars. 
Explorer Bars sind Teilbereiche der Oberfläche des Explorers, 
welche nicht zur Renderfläche der HTML Seite gehören.
Explorer Bars wurden erstmalig mit dem Internet Explorer 4.0 eingeführt 
und bieten eine sehr flexible Möglichkeit den Explorer zu erweitern. 
Derzeit werden Funktionen wie Favorieten und die Suche innerhalb einer 
Explorer Bar dargestellt. Die Darstellung von Explorer Bars kann entweder Horizontal 
oder Vertikal erfolgen und sie werden über den Menu Ansicht -> Explorerleisten ein- und ausgeblendet.

\paragraph{Tool Bands}

Die Werkzeugleiste des Internet Explorers ist eine sogenannte ``Rebar'', 
also ein Container der wiederum mehrere Werkzeugleisten enthalten kann. 
Diese Werkzeugleisten werden Toolbands genannt. Erstmalig wurde das Konzept 
mit dem Internet Explorer 5.0 eingeführt um die Radio Leiste zu realisieren. 
Mittlerweile gibt es verschiedene Toolbands wie die Adressleiste und auch 
Fremdanbieter wie Google und Yahoo nutzen das Konzept.

\paragraph{Deskbands}

Diese Komponenten verfolgen den selben Ansatz, haben aber primär nichts mit dem Internet 
Explorer zu tun. Sie dienen dazu den Desktop um weitere Leisten zu erweitern. 
Berühmtester Vertreter dieser Kategorie ist die Adressleiste. 
Sie kann ausser im Explorer und Internet Explorer auch in der Taskleiste erscheinen.

\subsubsection{Entwicklung der Band Objekte}

Die Entwicklung dieser Komponenten basiert, wie ein sehr großer Teil der 
Windowsentwicklung auf COM. Das Component Objekt Model von Microsoft 
ist eines der ältesten Komponentensysteme und bildet Zusammen mit dem 
Windows API die Grundlage für die Entwicklung von Windowssoftware.

\subsubsection{COM, Schnittstellen, Klassen, Registry}

Im folgende soll ein kurzer Überblick über COM gegeben werden, 
der die Schritte auf dem Weg zu Entwicklung der Band Objects erklärt.

\paragraph{COM Schnittstellen}

Zentrales Konzept von COM ist das Interface. In der COM Terminologie
 ist eine Schnittstelle, eine nach der COM Spezifikation aufgebauten, 
 Struktur mit Platzhaltern für Funktionszeiger. 
Diese Erklärung macht bereits deutlich auf welchem Level COM 
ursprünglich definiert worden ist.
Schnittstellen können von Komponenten erfragt werden, und anschließend über 
die Methodenzeiger entsprechende Funktionen aufgerufen werden. 
In einer einfachen - praktisch puren - COM Application muss man das 
Aussehen der Schnittstellen genau kennen. Später kam ein Feature mit dem 
Namen ``OLE Automatisierung'' hinzu, welches ähnliche Konzepte wie Java Reflection bietet.
Jede Schnittstelle wird eindeutig über einen GUID - Global Unique Identifier - indentifiziert.
  
\paragraph{COM Komponenten}

Eine Komponente in der COM Terminologie ist eine abgeschlosse binäre Einheit, 
welche Funktionalität über eine Schnittstelle bereitstellt. 
Komponenten sind also in Programmen (Executables) oder Bibliotheken (Dynamic Link Libraries) enthalten.

\paragraph{Registry}

Normalerweise, auch wenn das problemlos möglich wäre, 
wird eine COM Bibliothek nicht direkt referenziert und geladen. 
Stattdessen nutz man Funktionen der COM API um eine Instanz einer Komponente mit einer 
bestimmten Schnittstelle zu erhalten. Dazu übergibt man der Funktion die GUID der 
Schnittstelle welche man nutzen möchte. Diese Funktion bemüht die Windows Registry 
um die Bibliothek zu finden in der die Komponente mit der Schnittstelle implementiert ist, 
lädt diese, erzeugt die Komponente und gibt die Schnittstelle zurück.
Damit das funktioniert, ist jede COM Komponente vor ihrer Benutzung in der Registry einzutragen.

\subsubsection{Band Objekte und COM}

Alle Band Objekte sind wiederum COM Komponenten, welche bestimmte Schnittstellen 
implementieren müssen. Diese Schnittstellen werden vom Internet Explorer erwartet und abgefragt. 
Für die Entwicklung von Band Objekten müssen in jedem Fall die folgenden Schnittstellen implementiert werden:

\paragraph{IUnknown}

Das ist die Basisschnittstelle welche jedes COM Objekt implementieren muss. 
Sie bietet Funktionen zum Abrufen weiterer Schnittstellen sowie zur Referenzzählung.

\paragraph{IClassFactory}

Bietet Funktionen zum Erzeugen neuer Instanzen von COM Klassen.

\paragraph{IDeskBand}

Das ist die Basisschnittstelle für alle Band Objekte. IDeskBand erbt von 
IDockingWindow welches wiederum von IOleWindow erbt. Anhand der Namen der 
Schnittstellen lassen sich ungefähr die Funktionen ableiten.
IOleWindow liefert das Fenster (jedes Element in Windows ist ein Fenster) 
an sich, IDockingWindow sorgt für das Anzeigen und Deaktivieren und 
IDeskBand liefert Informationen über das Band Objekt an sich.

Mit Hilfe von GetBandInfo kann der Internet Explorer ermitteln wie 
die Leiste heist, wie sie dargestellt werden soll und welche Größen sie haben darf.

\paragraph{IObjectWithSite}

Über diese Schnisttelle hat man die Möglichkeit mit dem Container 
- also mit dem Internet Explorer zum Beispiel - des Band Objektes zu 
kommunizieren. Der Internet Explorer ist selbst ebenfalls ein COM Objekt 
welches diverse Schnittstellen implementiert. Über die SetSite Funktion 
weist er dem Band Objekt die eigene IUnknown Schnittstelle zu.

\paragraph{IPersistStream}

Diese Schnittstelle wird vom Container verwendet um den Zustand des Band 
Objekts zu speichern oder zu laden. Das Band Objekt implementiert diese 
Schnittstelle um sich selbst in den übergebenen Stream zu serialiasieren oder zu deserialisieren

Daneben gibt es noch einige weitere Schnittstellen z.B. für Benutzereingaben, 
auf welche hier jedoch nicht näher eingegangen werden soll.

\subsubsection{Registrierung der Band Objekte}

Jedes Band Objekt muss wie bereits erwähnt, als COM Objekt registriert werden. 
Darüber hinaus muss dem Internet Explorer nocht mitgeteilt werden, das er eine 
Toolleiste zur Verfügung hat. Dies geschieht ebenfalls über einen Eintrag in der Windows Registry.

\subsubsection{Die BandObject Library}

Alles was im Abschnitt COM und Band Object Entwicklung beschrieben worden ist, 
nimmt einem die Band Objekt Library ab. Der ganze ``schmuzige'' COM Teil wird durch 
eine CSharp Klasse gekapselt welche von UserControll erbt und all die Schnittstellen implementiert. 
Was dem Entwickler der Toolbar bleibt ist eine Klasse zu erstellen 
welche von der BandObject erbt. Da BandObject selber von UserControl 
erbt, steht einem auch der visuelle Designer zum erstellen der Toolbar zur Verfügung.
Die Funktionalität der Toolbar kann also bequem in CSharp erfolgen.

\subsubsection{Teamfound Internet Exlorer Toolbar}

\paragraph{Entwicklung}


Installation

Für die Installation auf einem Client PC kopiert man alle im Paket enthaltenen Quellen in einen Ordner.
Die Toolbar lässt dann einfach mit dem Install.cmd installieren. Im wesentlichen passiert dabei folgendes:

Die Bibliotheken BandObject.dll und Teamfound.IE.dll werden als COM Objekt registriert und im globalen Assembly Cache registriert. 

Alle anderen Bibliotheken werden ebenfalls im globalen Assemblycache registriert.



\section{Projektablauf, organisation, Meilensteine}


\section{Fazit}

\end{document}

