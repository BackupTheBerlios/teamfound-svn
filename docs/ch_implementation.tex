\chapter{Teamfound-Server}
\index{Server}
\section{Vor"uberlegungen}
\subsection{Anforderungen}

In der Vorbereitung des Projektes wurde unter anderem auf die Verzweigung von Open Source-Projekten eingegangen: Es soll nicht jedesmal das Rad neu erfunden werden, eine wichtige Herausforderung im Open Source-Entwicklungsmuster ist es einerseits andere geeignete Projekte zu finden und diese dann effektiv in das eigene Projekt zu integrieren. In diesem Sinne war die erste Phase in der TeamFound-Entwicklung von Recherchearbeiten geprägt. Für den TeamFound-Server heisst das: Es muss eine Bibliothek gefunden werden, welche uns die Volltextindexierung von beliebigen Dokumenten möglich macht. Diese Bibliothek muss dann - sofern sie dieses nicht schon selber anbietet - geeignet ans Internet gebracht werden, einerseits um neue Dokumente herunterzuladen und in den Index aufzunehmen, andererseits um Suchanfragen entgegenzunehmen und deren Ergebnisse zurückzugeben.
Diese Bibliothek sollte möglichst erweiterbar sein, um auch die Anforderungen von (relativ) einfachen Dokumentenkategorien umsetzen zu können. Für die Verwaltung der Kategorien würde eine Datenbank benötigt werden, da die Verknüpfung von Kategorien, sowie deren Details, wie Namen und Beschreibung nichts mit der Index-Bibliothek zu tun haben.

\subsection{Plattform}
\label{platform}
Die Entscheidung für eine Plattform wurde implizit durch die Entscheidung für eine Bibliothek zum indexieren und durchsuchen von Dokumenten getroffen. Nachdem einige Tage nach derartigen Bibliotheken Ausschau gehalten wurde, ist sehr schnell deutlich geworden, das Lucene \footnote{www.lucene.de} vom Apache-Projekt\footnote{http://www.apache.org} die am weitest entwickelte Bibliothek ist. Ein weiterer Vorteil ist die aktive Community rund um Lucene, so wurde während unserer Entwicklung noch ein Sprung von Version 1.5 auf 1.9 mitgemacht. Andere Bibliotheken, zum Beispiel in Perl oder PHP boten keine ausreichende Dokumentation oder Erweiterbarkeit.
Die ursprüngliche Lucene-Version ist in Java implementiert, ein weiteres Projekt bemüht sich um dessen Umsetzung in C und mittlerweile (Am Ende des Projekts hat Zend Technologies\footnote{http://www.zend.com} einen PHP-Wrapper\footnote{http://framework.zend.com/manual/en/zend.search.html} für Lucene veröffentlicht.

Somit war die Wahl der Plattform auf Java gefallen, eine erste mehr als Proof-of-Concept anzusehende Version von Teamfound wurde mittels zwei Perl-CGI-Scripten und einem Systemaufruf der Lucene-Bibliothek umgesetzt. Dieses Vorgehen startet bei jeder Anfrage an den Webserver eine neue Java virtuel machine, was natürlich überhaupt nicht effektiv ist. 

Daher fiel eine weitere Entscheidung, für eine Java-Servlet-Umsetzung, um die benötigte Umgebung für Anfragen an den Lucene-Index nicht für jedes Request neu zu schaffen. Somit besteht der Server aus einer 100\%igen Java-Umgebung und es entfällt damit die Notwendigkeit für aufwändige und zeit-kostende Wrapper um mehrere Programmiersprachen zu verbinden.


\section{Bibliotheken} 

\subsection{Apache Lucene}
\label{lucene}

\subsubsection{Allgemein}

Lucene ist - laut eigener Aussage - der harte Teil einer Suchmaschine. Diese Bibliothek erzeugt und durchsucht einen Volltextindex, kümmert sich aber weder darum wo die Daten herkommen, wie die Ergebnisse präsentiert werden oder wie die Suchanfragen vom Benutzer an den Index kommen. Der Index ist hingegen bietet viele Möglichkeiten die eigenen Daten zu analysieren und in sogenannten Dokumenten in den Index zu speichern. Eigene $Analyzer$ sind mit wenig Aufwand umzusetzen (sofern die mitgelieferten nicht ausreichen), auch aufwändigere Parser sind möglich, wie es zB. für HTML-Seiten notwendig ist.
Darüberhinaus kann jedes Dokument im Index beliebige $Felder$ enthalten, ein Feld ist als Inhaltselement eines Dokuments zu verstehen (Überschrift, Inhalt, Beschreibung). Dabei können völlig verschiedene Arten von Dokumenten in einem Index gespeichert werden sowie Suchanfragen direkt an ein oder mehrere Felder gestellt werden. Diese starke Erweiterbarkeit ist zum Beispiel bei der Implementierung von Dokumentenkategorien in TeamFound sehr wichtig gewesen (Siehe Kapitel \ref{kategorien})

\subsubsection{Wichtige Komponenten}


\paragraph{Document und Field}


Ein Lucene-\texttt{Document} ist die Basisspeichereinheit in einem von Lucene erstellten Index. Die Argumente bzw. Ergebnisse beim Einf"ugen und Suchen sind immer Lucene-\texttt{Documents}. 

Diese Dokumente bestehen aus einer variablen Anzahl von Feldern (\texttt{Field}).
Um ein Dokument zu erstellen kann man beliebig Felder definieren. Sinnvollerweise ist 
mindestens ein Inhaltsfeld definiert. Dieses wird in Token zerlegt und indiziert.
Au"serdem ist es zweckm"a"sig weitere Felder zu definieren, die nicht indiziert oder zerlegt,
sondern als zus"atzliche Information gespeichert werden. Ein eindeutiges Schl"usselwort
oder eine URL sind typisch, da nur so eine Unterscheidung von Dokumenten m"oglich wird.
Es k"onnen beliebig weitere Felder angelegt werden z.B. Author, Adresse, Zusammenfassung
oder Kathegorie. 

Allerdings werden Felder generell uninterpretiert als Text abgelegt.
Ausser Felder (wie das Inhaltsfeld), die zerlegt und indiziert werden. Diese sind 
textuell nicht wiederherstellbar, aber jetzt mithilfe von Anfragen durchsuchbar. 


\paragraph{Analyzer}


	Der \texttt{Analyzer} zerlegt zu indizierende Felder 
in Tokenstreams, damit diese dann ausgewertet werden k"onnen.
Das kann beliebig komplex oder simple sein. Ein Analyzer kann z.B. speziell auf eine 
bestimmte Sprache ausgelegt sein um Artikel, Pronomen etc. direkt ausfiltern oder einfach
anhand von $Whitespaces$ Token bilden. Als Nutzer von Lucene bestehen hier beliebig 
M"oglichkeiten selbst zu erweitern um eigene Anspr"uche zu erf"ullen.  

Genauso ist es m"oglich verschiedene \texttt{Analyzer} zu verbinden 
um unterschiedliche Felder auf unterschiedliche Weise zu zerlegen.


\paragraph{Query und QuerryParser}


Um nun indizierte Felder zu durchsuchen ist die
Grundeinheit die \texttt{Query}. Der Name ist etwas irref"uhrend, da es sich hierbei noch
nicht um wirkliche Anfragen handelt. Eine \texttt{Query} besteht erstmal nur aus einem 
einzelnen Token. Nach diesem k"onnte gesucht werden. Lucene bietet nun verschiedenste
M"oglichkeiten solche Grundsteine in vielf"altiger Art zu kombinieren um komplexere
Anfragen zu bilden. Dies ist vorallem sinnvoll f"ur Anfragen, die sich oft wiederholen und
automatisiert gestellt werden.

Um allerdings nach von Menschen formulierten Anfragen zu suchen,
bietet Lucene eine Erleichterung. Der \texttt{QuerryParser} stellt eine einfache Syntax zur
Verf"ugung. Diese wird ausgewertet und liefert die komplexe Anfrage f"ur den Index.
Die Syntax ist "ahnlich der von Google oder anderer Suchseiten.
( siehe Literaturverzeichnis LucQS )



\subsection{HSQLDB}
Die Entscheidung keine f"ur Webapplikationen typische Datenbank wie MySQL einzusetzen 
ist leicht erkl"art. Wie schon in Kapitel \ref{platform} beschrieben, sollte eine 
Java-Umgebung eingesetzt werden.
Das schr"ankt erstmal nur auf Datenbanken ein, die JDBC kompatibel sind.
Deshalb ist der Server auch leicht um einen weiteren Datenbanklayer zu erweitern, falls
andere Datenbanken erw"unscht sind.

HSQLDB wurde von uns ausgew"ahlt, weil wir sie als kleine Java-Bibliothek einbinden k"onnen
und es damit den Nutzern unseres Servers ersparen sich extra um einen Datenbankserver zu k"ummern.
HSQLDB kann als Server oder in Programme eingebettet laufen.
In der derzeitigen Version nutzen wir den eingebetteten Modus, und haben somit eine
kleine Datenbank f"ur den Teamfoundserver allein.
Die "ublichen Riten wie Datenbanknutzer anlegen usw. k"onnen wir dadurch im Server selbst automatisiert regeln.
HSQLDB hat sehr gute Ergebnisse in dem PolePosition benchmark (siehe Literaturverzeichnis PolPos) geliefert und unterst"utzt einen grossteil der ANSI-92 SQL, SQL 99 und 2003 Standards bis hin zu Transaktionen.
Ausserdem wird HSQLDB in einigen bekannten Projekten(z.b. JBoss, Mathematica, OpenOffice)  erfolgereich eingesetzt, was uns ausreichend von der Zuverl"assigkeit "uberzeugt hat.


\subsection{Weitere Bibliotheken}

Zur Erzeugung der XML-Antworten (Siehe Kapitel \ref{response}) wird die JDOM-Bibliothek\footnote{http://www.jdom.org} von Jason Hunter benutzt. JDOM ist eine abgewandelte DOM-Implementierung\footnote{Document Object Model} und bietet die Möglichkeit mit einfachen Java-Code sauberes XML zu erzeugen. JDOM wird ebenfalls benutzt um die XML-Dokumente in HTML zu wandeln, sofern der Client dieses wünscht.

\section{Architektur}

\begin{figure}[h]
\includegraphics[width=16cm]{bilder/aufbau2.eps}
\caption{grobe ServerArchitektur}
\label{serverarchgrob}
\end{figure}




\subsection{Servlet}

Das Servlet ist der Einstiegspunkt für jegliche Anfragen an TeamFound. Dem Servlet kommt dabei die Rolle eines Wächters zu, welcher überprüft ob notwendige Parameter für die einzelnen Anfragen vorhanden sind. Ist eine Anfrage gültig, wird diese an den sogenannten Controller weitergereicht, welcher die eigentlichen TeamFound-Komponenten steuert. Dieser Controller gibt immer ein Response-Objekt zurück, welches vom Servlet dann zB. als XML oder HTML serialisiert und als Antwort zum Client geschickt wird.

\subsection{Controller}

Die Hauptaufgabe des Controllers besteht darin die Teilaufgaben, die sich aus einer 
Anfrage ergeben, koordiniert an Datenbank und Index zu stellen.
Ausserdem sorgt er f"ur den Download der zu indizierenden Dokumente.

Die Zugriffe auf den Index werden dabei durch eine Instanz eines Indexers erledigt.
Um die Zugriffe der Indexer auf den Index zu steuern, besitzt der Controller ein
Semaphorobjekt. Dieses realisiert eine Leser-Schreiber-Kooperation der beauftragten
Indexer.

Der Zugriff auf die Datenbank erfolgt "uber den DBLayer. Dieser stellt
s"amtliche Funktionalit"at zum lesen und schreiben der Datenbank zur
Verf"ugung.

Wenn alle Teilaufgaben erf"ullt sind (siehe Abl"aufe \ref{request}), generiert der Controller aus den 
erhaltenen Informationen eine Response und "ubergibt diese dem Servlet.

\subsection{Indexer}
Der Indexer ist f"ur die Arbeit direkt am Lucene-Index verantwortlich. Er f"ugt 
Dokumente (siehe \ref{lucene}) in den Index ein oder entfernt sie wieder. 
Ausserdem f"uhrt er Suchanfragen auf dem Index aus.
Die von uns definierte Dokumentenstruktur (siehe \ref{docstruktur}) ist bereits im Cotroller bekannt, 
somit kann der Indexer vorgefertigte Dokument erhalten und als Ergebnis liefern. 
Zur Indizierung und zur Suche benutzt der Indexer 
einen eigenen Analyzer (siehe \ref{lucene}), 
der wird haupts"achlich ben"otigt um das Kategorienfeldi (siehe \ref{docstruktur}) korrekt zu zerlegen.

Die Anfragen werden zu eiem teil durch den QueryParser (siehe \ref{lucene}) und zum 
anderen vom Indexer generiert. Der Indexer erstellt dabei die Einschr"ankung
welche Kategorien in der Anfrage g"ultig sind.
Aus beiden teilen wird die gesammte Anfrage gebildet und an den Index gestellt.
Die Verarbeitung der Ergebnisse "ubernimmt der Controller.

\subsection{Response}

Antworten werden in TeamFound immer als XML generiert, diese XML\-Repräsentation kann bevor sie zum Client geschickt wird, noch mittels XSLT in eine geeignete HTML\-Fassung gewandelt werden.
Eine Basisklasse Response übernimmt dabei das Handling des eigentlichen JDOM-Document-Objektes, während die eigentlichen Antwort\-Klassen, wie SearchResponse oder AddPageResponse ihre eigentlichen Inhalte an die Standardelemente einer Antwort anhängen (Siehe dazu mehr im Kapitel Protokoll TODO: LINK).


\section{Datenmodell}

\subsection{Datenbank}

\begin{figure}[h]
\includegraphics[width=16cm]{bilder/db.eps}
\caption{Datenbank-ERD}
\label{dberd}
\end{figure}




\subsection{Dokumentstruktur}
\label{docstruktur}

\subsection{Kategorienbaum}
\begin{figure}[h]
\includegraphics[width=16cm]{bilder/katstruktur.eps}
\caption{Repr"asentation der Kategorien in DB und Index}
\label{katstruktur}
\end{figure}




\section{Abl"aufe im Server}
\label{request}

\subsection{AddpageRequest}
\label{addpagerequest}

\begin{figure}[h]
\includegraphics[width=16cm]{bilder/ablaufaddpage1.eps}
\caption{Indizieren einer neuen URL}
\label{addpage1}
\end{figure}


\subsection{Ablauf SearchRequest}
\label{searchrequest}

\subsection{Ablauf GetCategoriesRequest}
\label{getcatrequest}


\chapter{Protokoll}

\section{Zielsetzung und Sinn des Protokolls}
\section{Umsetzung (Designentscheidungen, Technik,...)}
\section{Interface Milestone 1}

\subsection{Seite hinzufügen}
\begin{description}
\item[Request] http://url/addpage.pl?url=http://yy.org/blabla.html
\item[Antwort] keine
\end{description}

\subsection{Suchen}
\begin{description}
\item[Request] http://url/search.pl?keyword=zzz
\item[Antwort] HTML-Seite mit URLs gefundener Übereinstimmungen 
\end{description}

\section{Interface Milestone 2}
\subsection{Allgemein}
\subsubsection{Tests}
Zum Testen der Serverseitigen Interface-Implementation existiert folgende Webseite die entsprechende Requests erstellen kann: 

\texttt{http://teamfound.berlios.de/test\_the\_server\_interface\_m2.html}
\\
\\
Zum Testen der Clientseitigen Interface-Implementation existiert folgendes Perl-Skript, welches den Parameter command auswertet und eine enstsprechende statische XML-Antwort zurueckgibt: 
\\
\texttt{http://teamfound.dyndns.org/interface-m2/testmilestone2.pl}
\\
Demo: 
\\
\texttt{http://teamfound.dyndns.org/interface-m2/testmilestone2.pl?command=getcategories}
\\
Das Skript liegt auch im SVN unter \texttt{teamfound/interface/milestone2/testmilestone2.pl}

\subsubsection{Alle Anfragen an den Server}

Alle Anfrage-Parameter werden in Form von HTTP GET oder POST Variablen übertragen. (solange wir Perl-Skripte verwenden die das CGI-Modul verwenden ist das total egal und ändert nicht eine einzige Code-Zeile ;-)

\begin{description}
\item[want=xml or html] Die zu erwartende Antwort soll in xml oder html-format sein (default soll html werden, da dann einfache Link-Clients möglich sind) 

\item[version=2] Milestone-Version des Interfaces 

\item[command=search] Das Kommando das ausgeführt werden soll. Dieses Argument kann wegfallen wenn für jedes Kommando eine eigene, gleichnamige Anfrage-URL existiert. 
\end{description}

\subsubsection{HTML-Antwort}
Die Clients geben an ob Sie eine HTML oder eine XML Antwort erwarten.

Soll eine vollständige HTML-Seite zurückgeben, die direkt im Browser angezeigt werden kann. Die Return-Values wie bei einer XML-Antwort müssen in diesem Fall nicht zurückgegeben werden, sondern der Text sollte gleich eine entsprechende Meldung beinhalten.

\subsubsection{XML-Antwort}
\begin{description}
\item[$<$response$>$] Umschliesst alle anderen xml-tags und gibt die XSD-Datei zum verifizieren der XML-Daten an 
\item[$<$interface-version$>$] Gibt immer die Interface-Version an, in der die Antwort des Servers formuliert wurde 
\item[$<$server$>$] Gibt Name und Versionsnummer des Servers an. Der Server der unter der URL https://developer.berlios.de/projects/teamfound entwickelt wird gibt den Namen "TeamFound" zurück. Clones dürfen Ihren eigenen Namen natürlich frei wählen. 
\item[$<$addpage$>$ $<$search$>$ $<$addcategory$>$ $<$getcategories$>$] Diese Tags beinhalten die Antworten auf die gleichnamigen Anfragen an den Server. Pro Anfrage darf nur eines dieser Tags vorkommen. 
\item[$<$return-value$>$ $<$return-description$>$] Der Return-Value bzw. Fehler-Code falls etwas schiefging. Die Description wird nicht genauer spezifiziert, sollte aber semantisch mit dem aufgetretenen Fehler übereinstimmen. 
\item[$<$project-counter$>$] Bei jeder Änderung des Kategorien-Baumes(Graph!) soll der Server einen internen Zähler um eins inkrementieren. Der aktuelle Wert soll bei jeder XML-Antwort mit übertragen werden. (Dann weiss die Toolbar wann sie selber die Kategorien neu vom Server abfragen muss.)Jedes Projekt fuehrt einen Counter, somit muss der Client nur die fuer ihn intressanten Baeume beachten. 
\end{description}

\begin{verbatim}
<response xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="teamfound-interface-milestone2.xsd">

 <interface-version>2</interface-version>

 <return-value>0</return-value>
 <return-description>OK</return-description>

 <project-counter>
   <project>
     <projectID>0</projectID>
     <count>3</count>
   </project>
   <project>
     <projectID>3</projectID>
     <count>5</count>
   </project>
 </project-counter>

 <category-counter>54</category-counter>

 <server>
  <name>TeamFound</name>
  <version>0.2</version>
 </server>

 <addpage>
 </addpage>

 <search>
 </search>

 <addcategory>
 </addcategory>

 <getcategories>
 </getcategories>
 
</response>
\end{verbatim}

\paragraph{Return Codes}

Die Return-Codes stehen immer in den Tags $<$return-value$>$xx$<$/return-value$>$. Die Description ist optional.

\begin{description}
\item[0] Alles ok 

\item[1] Fehler, konnte URL nicht finden 

\item[2] Ungültige Anfrage (Pflicht-Parameter fehlen oder haben die Länge null) 

\item[3] Inkompatible Interface-Version (die Anfrage hat eine Interface-Version benutzt die der Server nicht unterstützt) 

\item[4] Kategorie existiert schon (beim hinzufuegen einer neuen Kategorie) 

\item[5] Kategorie nicht gefunden (beim suchen nach einer bestimmten Kategorie) 

\item[-1] Anderer Fehler 
\end{description}

Die Return-Descriptions sind frei wählbar, sollten aber dem Return-Code semantisch entsprechen ;-)


\subsection{Seite hinzufügen}
\subsubsection{Anfrage an Server}

\begin{description}
\item[command=addpage] Der Kommando-Name 

\item[addpage.pl] Der (default) Skriptname der die Anfrage entgegennimmt (dann fällt das Argument command weg). 

\item[category=453] Die Kategorien-Nummer zu der der Link hinzugefuegt werden soll, in dieser Version nur genau eine oder keine. Wird keine Kategorie angegeben, so soll die Top-Kategorie genommen werden (also nicht gefunden werden wenn bei der Suche eine genauere Kategorie angegeben wird). 

\item[url=http://yy.org/blabla.html] Die zu indizierende url, das Protokoll ist mit anzugeben 
\end{description}

\subsubsection{XML Antwort}
xml oder html um über Erfolg oder Misserfolg zu berichten

Verwendet in der Antwort das XML-Tag: $<$addpage$>$
\begin{verbatim}
<response>

 <interface-version>2</interface-version>

 <return-value>0</return-value>
 <return-description>OK</return-description>

 <server>
  <name>TeamFound</name>
  <version>0.2</version>
 </server>

 <addpage>
  <url>http://blabla.html</url>
 </addpage>
 
</response>
\end{verbatim}

\subsubsection{HTML Antwort}
siehe Allgemeines zu HTML-Antworten


\subsection{Suchen}
\subsubsection{Anfrage an Server}
\begin{description}
\item[command=search] Der Kommando-Name 

\item[search.pl] Der (default) Skriptname der die Anfrage entgegennimmt (dann fällt das Argument command weg). 
\item[keyword=zzz] Eine durch ' ' (space) getrennte Liste der Suchwörter die alle vorkommen sollen (URL-Codiert mit \"\%20\" getrennt, also eine Suche nach auto und tv wird als keyword=auto\%20tv codiert). Dies beinhaltet eine serverseitig impliziete UND-Verknüpfung aller Suchworte. Fehlt der Parameter so soll ein Fehler zurückgegeben werden. Die genaue Definition einer umfassenderen Suchanfragen-Sprache (wie OR, NOT etc.) ist noch festzulegen, wird aber auf spaetere Interface-Milestones verschoben. 

\item[category=5\&category=9\&category=15] Eine Liste aller Kategorien-IDs, jeweils immer wieder neu mit category= durch die die Suche gemacht werden soll. Fehlt der Paramater, so soll alles durchsucht werden. (Grund: HTML-Formulare machen dies bei Listen und ComboBoxen mit Mehrfachauswahl genau so). 
\end{description}

\subsubsection{XML Antwort}
Verwendet in der Antwort das XML-Tag: $<$search$>$

\begin{verbatim}
<response>

 <interface-version>2</interface-version>

 <return-value>0</return-value>
 <return-description>OK</return-description>

 <server>
  <name>TeamFound</name>
  <version>0.2</version>
 </server>

 <search>

  <keywords>
   <word>xxx</word>
   <word>yyy</word>
  </keywords>

  <result>

   <count>30</count>
   <offset>0</offset>

   <found>
    <url>http://xxx.html</url>
    <title>Der Titel der Seite</title>
    <incategory>5</incategory>
   </found>

   <found>
    <url>http://xxx.html</url>
    <title>Der Titel der Seite</title>
    <incategory>5</incategory>
   </found>

   <found>
    <url>http://xxx.html</url>
    <title>Der Titel der Seite</title>
    <incategory>5</incategory>
    <incategory>3</incategory>
    <incategory>7</incategory>
   </found>

  </result>
 </search>
 
</response>
\end{verbatim}
\begin{itemize}
\item Die Keywords sind zur Fehlerbehandlung alle nochmals mit anzugeben. 

\item Jeder gefundene Link wird in einem eingenen $<$found$>$ Block augegeben. 

\item Wurde kein Suchergebnis gefunden, so ist in $<$count$>$ die Anzahl 0 einzutragen, der Return-Code aber immernoch 0 (OK) wenn sonst alles ok war 
\end{itemize}

\subsubsection{HTML Antwort}
HTML-Seite mit URLs gefundener Übereinstimmungen

\subsection{Kategorien von Server abfragen}
\subsubsection{Anfrage an Server}

\begin{description}
\item[command=getcategories] Der Kommando-Name 
\item[getcategories.pl] Der (default) Skriptname der die Anfrage entgegennimmt (dann fällt das Argument command weg). 
\item[projectID=5] Nummer des projekts für diese Anfrage 
\end{description}

\subsubsection{XML Antwort}
Verwendet in der Antwort das XML-Tag: $<$getcategories$>$
\begin{verbatim}
<response>

 <interface-version>2</interface-version>

 <return-value>0</return-value>
 <return-description>OK</return-description>

 <server>
  <name>TeamFound</name>
  <version>0.2</version>
 </server>

 <getcategories>
  <category>
   <name>name der kategorie</name>
   <description>laengere beschreibung</description>
   <id>0</id>
   <subcategories>
    <category>
     ...
    </category>
    <category>
     ...
    </category>
   </subcategories>
  </category>
 </getcategories>
 
</response>
\end{verbatim}

Hinweis: die Top-Kategorie hat immer die ID 0 (null) 

\subsubsection{HTML Antwort}
siehe Allgemeines zu HTML-Antworten

\subsection{Kategorie hinzufügen}
\subsubsection{Anfrage an Server}
\begin{description}
\item[command=addcategory] Der Kommando-Name 

\item[addcategory.pl] Der (default) Skriptname der die Anfrage entgegennimmt (dann fällt das Argument command weg). 

\item[name=kategoriename] Den Namen den die neue Kategorie bekommen soll 

\item[subcategoryof=45] Die Kategorie der die neue Kategorie untergeordnet werden soll. Soll eine neue 1st-Level Kategorie erstellt werden ist hier 0 (null) anzugeben. 

\item[description] Eine etwas längere Beschreibung der Kategorie (max. 255 Zeichen) 
\end{description}

\subsubsection{XML Antwort}
Verwendet in der Antwort das XML-Tag: $<$addcategory$>$
\begin{verbatim}
<response>

 <interface-version>2</interface-version>

 <return-value>0</return-value>
 <return-description>OK</return-description>

 <server>
  <name>TeamFound</name>
  <version>0.2</version>
 </server>

 <addcategory>
  <name>kategoriename</name>
  <gotid>53</gotid>
 </addcategory>
 
</response>
\end{verbatim}
\begin{itemize}
\item der neue Name
\item die ID die die neue Kategorie bekommen hat
\item name und gotid fallen weg wenn die kategorie schon existiert (return-value 4 - Kategorie existiert schon) oder die subcategoryof-id nicht existiert (return-value 5 - Kategorie nicht gefunden). 
\end{itemize}

\subsubsection{HTML Antwort}
siehe Allgemeine HTML-Antwort

\subsection{Alle Projekte auslesen}
\subsubsection{Anfrage an Server}
\begin{description}
\item[command=getprojects] Der Kommando-Name 
\item[addcategory.pl] Der (default) Skriptname der die Anfrage entgegennimmt (dann fällt das Argument command weg). 
\end{description}

\subsubsection{XML Antwort}
Verwendet in der Antwort das XML-Tag: $<$projects$>$
\begin{verbatim}
<response>

 <interface-version>2</interface-version>

 <return-value>0</return-value>
 <return-description>OK</return-description>

 <server>
  <name>TeamFound</name>
  <version>0.2</version>
 </server>

 <projects>
   <project>
     <name>prjectname</name>
     <description>beschreibung</description>
     <id>7</id>
   </project>
   ...
 </project>
 
</response>
\end{verbatim}

\subsubsection{HTML Anwort}
siehe Allgemeine HTML-Antwort

\subsection{Löschen einer Kategorie}
Wird erst in Interface Milestone 3 implementiert werden. Es stellt sich die Frage was mit den in dieser Kategorie bereits befindlichen Links gemacht wird .. verschieben?


\chapter{Clients}

\section{Web-Client}
Der Web-Client ist ein einfaches HTML-Formular (\texttt{$<$form$>$..$<$/form$>$}), welches Anfragen an den Server sendet und die Antwort direkt im Browser anzeigt. Dieser Client ist von daher praktisch, da man keine extra Erweiterung f"ur den Browser installieren muss, und von daher unpraktisch, da man die URL einer neu hinzuzuf"ugende Seite immer zuerst manuell kopieren, dann die Seite des Web-Clients laden und schliesslich die URL manuell eintragen muss.
\begin{figure}[h]
\epsfig{file=webclient}
\caption{Web-Client Screenshot}
\label{webclient}
\end{figure}

Als interessante Erweiterung, bot sich hier allerdings ein einfacher Javascript-Link an, der, als Bookmark in den eigenen Browser eingef"ugt, die Nachteile des Web-Clients zum Teil ausr"aumt:

\begin{verbatim}
javascript:location.href='http://serverurl/addpage.pl?
url='+encodeURIComponent(location.href)
\end{verbatim}

Mit diesem einfachen Link, kann das l"astige Kopieren umgangen werden, indem "uber Javascript die URL der aktuell im eigenen Browser angezeigten Seite, durch einen einfachen Click auf diesen Bookmark, direkt an den TeamFound-Server gesendet wird. (Beispiel ist f"ur Milestone 1)

\subsection{Implementation}
Die \textit{extrem einfache} Implementation des Web-Clients f"ur eine Suchanfrage entsprechend Milestone 2 sieht wie folgt aus:
\begin{verbatim}
<form action="serverurl">
	search: <input type="text" name="keyword">
	<input type="hidden" name="want" value="html">
	<input type="hidden" name="version" value="2">
	<input type="hidden" name="command" value="search">
	<input type="submit">
</form>
\end{verbatim}
Bei dem Design der TeamFound-Interfaces war diese M"oglichkeit der HTML-Formulare die entscheidende Grundlage. Alle Anfragen an den Server k"onnen mit HTML-Formularen ohne Zus"atze (wie Javascript, Applets, Extensions, etc.) generiert werden.

\section{Firefox-Toolbar}
Der Mozilla Firefox l"asst sich durch sogenannte \textit{Extensions} sehr einfach erweitern. Als grundlegende Techniken werden daf"ur XUL (XML User Interface Language) und Javascript ben"otigt. Desweiteren gibt es eine exakt vordefinierte Verzeichnisstruktur sowie eine Beschreibungs-Datei (\texttt{install.rdf}) im RDF (Resource Description Framework) Format, umd die Erweiterung automatisiert installierbar in Firefox-Browsern zu machen.

\begin{figure}[h]
\epsfig{file=ffextension-kategorien}
\caption{Firefox-Toolbar mit Kategorien-Baum (v0.8, Milestone 2)}
\label{fftoolbar}
\end{figure}

\begin{figure}[h]
\epsfig{file=ffextension-settings}
\caption{Firefox-Toolbar Settings Dialog (v0.8, Milestone 2)}
\label{fftoolbar}
\end{figure}

\subsection{Dateien}
Die Verzeichnisstruktur der TeamFound Firefox Extension sowie alle enthaltenen Dateien sind:
\begin{verbatim}
chrome.manifest
install.rdf

content/
- overlay.js  
- overlay.xul  
- settings.js  
- settings.xul

defaults/
- preferences/
  - settings.js

skin/
- icon.png  
- logo_tf_32x32.png  
- overlay.css  
- search_h.html  
- search_v.html  
- xmlstyle.css
\end{verbatim}

Die eigentliche Funktionalit"at steckt dabei in dem Unterverzeichnis content:
\begin{description}
\item[overlay.xul] Definiert das Aussehen der Toolbar
\item[overlay.js] Definiert die Funktionalit"at der Toolbar
\item[settings.xul] Definiert das Aussehen des Einstellungen-Dialogs
\item[settings.js] Definiert die Funktionalit"at des Einstellungen-Dialogs
\end{description}

\begin{figure}[h]
\epsfig{file=screenshot-search-server-0.1-firefox-toolbar-0.4.eps}
\caption{Firefox-Toolbar Suchergebnis (v0.4, Milestone 1)}
\label{fftoolbarsuchergebnis}
\end{figure}

\subsection{Changelog}
Das originale Changelog\footnote{\texttt{http://teamfound.berlios.de/\#firefoxchangelog0.7}} (in englischer Sprache):
\paragraph{Firefox \& Flock toolbar 0.7 (07-DEC-2005)}
\begin{itemize}
\item Bug-Fix: Add-Button actually works now
\item Label with current URL removed (though we are not going to replace the location-bar)
\item Compatibility with Flock browser tested and added to install.rdf
\end{itemize}

\paragraph{Firefox toolbar 0.6 (30-NOV-2005)}

\begin{itemize}
\item Input-field now behaves the same like the normal Firefox locationbar (including history popup) when urls are typed. Soon this can replace the Firefox locationbar and the Firefox searchbar with only one input-field ;-)
\item Settings-Dialog allows to give custom external search engines
\item Settings-Dialog allows to only search external, only search TeamFound or search both at once
\end{itemize}

\paragraph{Firefox toolbar 0.5 (28-NOV-2005)}

\begin{itemize}
\item Google search results are actually working now, including further results
\item Compatible with Firefox 1.5 release candidates
\end{itemize}

\paragraph{Firefox toolbar 0.4 (27-NOV-2005)}

\begin{itemize}
\item Clicking on TF-Icon opens preferences dialog, here you can setup your TeamFound server url and choose between two search result layouts
\item Add page - Adds the current page to the TeamFound-Index.
\item text field - Here you can enter search words or urls. The toolbar tries to automatically figure out what you meant and though will either search or just visit the given url.
\item current url - The current url is always displayed at the end of the toolbar, though not overwriting your current search words.
\end{itemize}

\paragraph{Firefox toolbar 0.3 (24-NOV-2005)}

\begin{itemize}
\item adds search at extern search-engine
\item shows google and teamfound search-results in same window
\end{itemize}

\paragraph{Firefox toolbar 0.2 (22-NOV-2005)}

\begin{itemize}
\item first release at berlios.de
\item available as .xpi
\end{itemize}

\paragraph{Firefox toolbar 0.1 (19-NOV-2005)}

\begin{itemize}
\item initial release
\end{itemize}

\section{Internet Explorer-Toolbar}

Auch beim Internet Explorer stand zunächst die Frage wie dieser überhaupt zu erweitern ist. 
Google und Yahoo haben mit ihren Toolbar's vorgemacht das es geht, nur das wie war zu lösen.

Erste Anlaufstelle um der Problemlösung näher zu kommen 
war CodeProject (www.codeproject.com). 
Mit 2,8 Mio Mitgliedern ist sie die größte Community Seite für die Windows Entwicklung. 
Eine Suche nach ``IE Toolbar'' führte zu einer .NET basierten Bibliothek 
für die Entwicklung von BandObjects, also Band Objekten (http://www.codeproject.com/csharp/dotnetbandobjects.asp).
Das mitgelieferte Beispiel funktionierte auf Anhieb 
und es wurde begonnen die Extension zu implementieren.

\subsection{Custom Explorer Bars, Tool Bands, and Desk Bands}

Es gibt verschiedene Möglichkeiten eigene Komponenten in den Internet Explorer zu integrieren. 
Im folgenden werden einige Konzepte vorgestellt.

\paragraph{Explorer Bars}

Ein zentrales Konzept zur Erweiterung des Internet Explorers, sind Explorer Bars. 
Explorer Bars sind Teilbereiche der Oberfläche des Explorers, 
welche nicht zur Renderfläche der HTML Seite gehören.
Explorer Bars wurden erstmalig mit dem Internet Explorer 4.0 eingeführt 
und bieten eine sehr flexible Möglichkeit den Explorer zu erweitern. 
Derzeit werden Funktionen wie Favorieten und die Suche innerhalb einer 
Explorer Bar dargestellt. Die Darstellung von Explorer Bars kann entweder Horizontal 
oder Vertikal erfolgen und sie werden über den Menu Ansicht -> Explorerleisten ein- und ausgeblendet.

\paragraph{Tool Bands}

Die Werkzeugleiste des Internet Explorers ist eine sogenannte ``Rebar'', 
also ein Container der wiederum mehrere Werkzeugleisten enthalten kann. 
Diese Werkzeugleisten werden Toolbands genannt. Erstmalig wurde das Konzept 
mit dem Internet Explorer 5.0 eingeführt um die Radio Leiste zu realisieren. 
Mittlerweile gibt es verschiedene Toolbands wie die Adressleiste und auch 
Fremdanbieter wie Google und Yahoo nutzen das Konzept.

\paragraph{Deskbands}

Diese Komponenten verfolgen den selben Ansatz, haben aber primär nichts mit dem Internet 
Explorer zu tun. Sie dienen dazu den Desktop um weitere Leisten zu erweitern. 
Berühmtester Vertreter dieser Kategorie ist die Adressleiste. 
Sie kann ausser im Explorer und Internet Explorer auch in der Taskleiste erscheinen.

\subsection{Entwicklung der Band Objekte}

Die Entwicklung dieser Komponenten basiert, wie ein sehr großer Teil der 
Windowsentwicklung auf COM. Das Component Objekt Model von Microsoft 
ist eines der ältesten Komponentensysteme und bildet Zusammen mit dem 
Windows API die Grundlage für die Entwicklung von Windowssoftware.

\subsection{COM, Schnittstellen, Klassen, Registry}

Im folgende soll ein kurzer Überblick über COM gegeben werden, 
der die Schritte auf dem Weg zu Entwicklung der Band Objects erklärt.

\paragraph{COM Schnittstellen}

Zentrales Konzept von COM ist das Interface. In der COM Terminologie
 ist eine Schnittstelle, eine nach der COM Spezifikation aufgebauten, 
 Struktur mit Platzhaltern für Funktionszeiger. 
Diese Erklärung macht bereits deutlich auf welchem Level COM 
ursprünglich definiert worden ist.
Schnittstellen können von Komponenten erfragt werden, und anschließend über 
die Methodenzeiger entsprechende Funktionen aufgerufen werden. 
In einer einfachen - praktisch puren - COM Application muss man das 
Aussehen der Schnittstellen genau kennen. Später kam ein Feature mit dem 
Namen ``OLE Automatisierung'' hinzu, welches ähnliche Konzepte wie Java Reflection bietet.
Jede Schnittstelle wird eindeutig über einen GUID - Global Unique Identifier - indentifiziert.
  
\paragraph{COM Komponenten}

Eine Komponente in der COM Terminologie ist eine abgeschlosse binäre Einheit, 
welche Funktionalität über eine Schnittstelle bereitstellt. 
Komponenten sind also in Programmen (Executables) oder Bibliotheken (Dynamic Link Libraries) enthalten.

\paragraph{Registry}

Normalerweise, auch wenn das problemlos möglich wäre, 
wird eine COM Bibliothek nicht direkt referenziert und geladen. 
Stattdessen nutz man Funktionen der COM API um eine Instanz einer Komponente mit einer 
bestimmten Schnittstelle zu erhalten. Dazu übergibt man der Funktion die GUID der 
Schnittstelle welche man nutzen möchte. Diese Funktion bemüht die Windows Registry 
um die Bibliothek zu finden in der die Komponente mit der Schnittstelle implementiert ist, 
lädt diese, erzeugt die Komponente und gibt die Schnittstelle zurück.
Damit das funktioniert, ist jede COM Komponente vor ihrer Benutzung in der Registry einzutragen.

\subsection{Band Objekte und COM}

Alle Band Objekte sind wiederum COM Komponenten, welche bestimmte Schnittstellen 
implementieren müssen. Diese Schnittstellen werden vom Internet Explorer erwartet und abgefragt. 
Für die Entwicklung von Band Objekten müssen in jedem Fall die folgenden Schnittstellen implementiert werden:

\paragraph{IUnknown}

Das ist die Basisschnittstelle welche jedes COM Objekt implementieren muss. 
Sie bietet Funktionen zum Abrufen weiterer Schnittstellen sowie zur Referenzzählung.

\paragraph{IClassFactory}

Bietet Funktionen zum Erzeugen neuer Instanzen von COM Klassen.

\paragraph{IDeskBand}

Das ist die Basisschnittstelle für alle Band Objekte. IDeskBand erbt von 
IDockingWindow welches wiederum von IOleWindow erbt. Anhand der Namen der 
Schnittstellen lassen sich ungefähr die Funktionen ableiten.
IOleWindow liefert das Fenster (jedes Element in Windows ist ein Fenster) 
an sich, IDockingWindow sorgt für das Anzeigen und Deaktivieren und 
IDeskBand liefert Informationen über das Band Objekt an sich.

Mit Hilfe von GetBandInfo kann der Internet Explorer ermitteln wie 
die Leiste heist, wie sie dargestellt werden soll und welche Größen sie haben darf.

\paragraph{IObjectWithSite}

Über diese Schnisttelle hat man die Möglichkeit mit dem Container 
- also mit dem Internet Explorer zum Beispiel - des Band Objektes zu 
kommunizieren. Der Internet Explorer ist selbst ebenfalls ein COM Objekt 
welches diverse Schnittstellen implementiert. Über die SetSite Funktion 
weist er dem Band Objekt die eigene IUnknown Schnittstelle zu.

\paragraph{IPersistStream}

Diese Schnittstelle wird vom Container verwendet um den Zustand des Band 
Objekts zu speichern oder zu laden. Das Band Objekt implementiert diese 
Schnittstelle um sich selbst in den übergebenen Stream zu serialiasieren oder zu deserialisieren

Daneben gibt es noch einige weitere Schnittstellen z.B. für Benutzereingaben, 
auf welche hier jedoch nicht näher eingegangen werden soll.

\subsection{Registrierung der Band Objekte}

Jedes Band Objekt muss wie bereits erwähnt, als COM Objekt registriert werden. 
Darüber hinaus muss dem Internet Explorer nocht mitgeteilt werden, das er eine 
Toolleiste zur Verfügung hat. Dies geschieht ebenfalls über einen Eintrag in der Windows Registry.

\subsection{Die BandObject Library}

Alles was im Abschnitt COM und Band Object Entwicklung beschrieben worden ist, 
nimmt einem die Band Objekt Library ab. Der ganze ``schmuzige'' COM Teil wird durch 
eine CSharp Klasse gekapselt welche von UserControll erbt und all die Schnittstellen implementiert. 
Was dem Entwickler der Toolbar bleibt ist eine Klasse zu erstellen 
welche von der BandObject erbt. Da BandObject selber von UserControl 
erbt, steht einem auch der visuelle Designer zum erstellen der Toolbar zur Verfügung.
Die Funktionalität der Toolbar kann also bequem in CSharp erfolgen.

\subsection{Teamfound Internet Explorer Toolbar}

\paragraph{Entwicklung}


Installation

Für die Installation auf einem Client PC kopiert man alle im Paket enthaltenen Quellen in einen Ordner.
Die Toolbar lässt dann einfach mit dem Install.cmd installieren. Im wesentlichen passiert dabei folgendes:

Die Bibliotheken BandObject.dll und Teamfound.IE.dll werden als COM Objekt registriert und im globalen Assembly Cache registriert. 

Alle anderen Bibliotheken werden ebenfalls im globalen Assemblycache registriert.



